const { PackageURL } = require('packageurl-js');
const _pLimit = require('p-limit');
const pLimit = (typeof _pLimit === 'function') ? _pLimit : (_pLimit && _pLimit.default) ? _pLimit.default : null;
if (!pLimit) {
    throw new Error('p-limit import failed: expected a function export');
}
const fetch = global.fetch || require('node-fetch');
const { VulnCache } = require('../db/vulnCache');

const OSV_BATCH_ENDPOINT = process.env.OSV_API_URL || 'https://api.osv.dev/v1/querybatch';
const OSV_VULN_ENDPOINT = process.env.OSV_API_URL_VULN || 'https://api.osv.dev/v1/vulns'; // use /v1/vulns/{id}

function extractPurlsFromCycloneDx(sbom) {
    // sbom.components is an array (CycloneDX)
    const components = (sbom && (sbom.components || sbom.Components)) || [];
    const results = [];
    for (const c of components) {
        // Prefer standard purl field
        if (c.purl) {
            results.push({ purl: c.purl, name: c.name || null, version: c.version || null, component: c });
            continue;
        }
        // Heuristic: group/name/version common for maven; try to construct purl for common ecosystems:
        const name = c.name || null;
        const version = c.version || null;
        const group = c.group || c.groupId || null;
        const type = (c.type || '').toLowerCase(); // sometimes 'library' etc
        if (name && version) {
            // Try a few heuristics
            // Maven: group + name -> pkg:maven/group/name@version
            if (group) {
                try {
                    const p = `pkg:maven/${encodeURIComponent(group)}/${encodeURIComponent(name)}@${encodeURIComponent(version)}`;
                    results.push({ purl: p, name, version, component: c });
                    continue;
                } catch (e) { }
            }
            // NPM guess
            if (name && !group && /^[a-z0-9@\/\-\._]+$/i.test(name)) {
                try {
                    const pn = name.startsWith('@') ? encodeURIComponent(name) : name;
                    const p = `pkg:npm/${pn}@${encodeURIComponent(version)}`;
                    results.push({ purl: p, name, version, component: c });
                    continue;
                } catch (e) { }
            }
            // PyPI guess
            try {
                const p = `pkg:pypi/${encodeURIComponent(name)}@${encodeURIComponent(version)}`;
                results.push({ purl: p, name, version, component: c });
                continue;
            } catch (e) { }
        }
        // If we get here, we couldn't reasonably identify -> keep record with null purl
        results.push({ purl: null, name: c.name || null, version: c.version || null, component: c });
    }
    return results;
}

function chunkArray(arr, size) {
    const chunks = [];
    for (let i = 0; i < arr.length; i += size) {
        chunks.push(arr.slice(i, i + size));
    }
    return chunks;
}

async function queryOsvBatch(purls) {
    // purls: array of strings (purl)
    // returns array of results aligned with purls order, each result: { vulns: [ {id, modified}, ...], next_page_token? }
    const queries = purls.map(p => ({ package: { purl: p } }));
    const body = JSON.stringify({ queries });
    const res = await fetch(OSV_BATCH_ENDPOINT, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body,
        // timeout not directly supported by fetch; ensure Node fetch supports AbortController if needed.
    });
    if (!res.ok) {
        const txt = await res.text().catch(() => '');
        throw new Error(`OSV batch query failed ${res.status}: ${txt}`);
    }
    const json = await res.json();
    return json.results || [];
}

async function fetchVulnDetail(id) {
    // Get /v1/vulns/{id}
    const url = `${OSV_VULN_ENDPOINT}/${encodeURIComponent(id)}`;
    const r = await fetch(url, { method: 'GET', headers: { 'Accept': 'application/json' } });
    if (!r.ok) {
        throw new Error(`OSV vuln fetch ${id} failed ${r.status}`);
    }
    return r.json();
}

async function getCachedVulnDetails(ids) {
    // bulk get from Mongo
    const docs = await VulnCache.find({ _id: { $in: ids } }).lean().exec();
    const map = new Map(docs.map(d => [d._id, d.data]));
    return map; // Map id -> data
}

async function cacheVulnDetail(id, data) {
    await VulnCache.updateOne({ _id: id }, { $set: { data, fetchedAt: new Date() } }, { upsert: true }).exec();
}

async function scanSbom(sbom, options = {}) {
    // sbom: CycloneDX object
    // returns summary object
    if (!sbom) throw new Error('No SBOM provided to scan');

    const extracted = extractPurlsFromCycloneDx(sbom);
    const withPurl = extracted.filter(e => e.purl);
    const totalComponents = extracted.length;

    // dedupe purls
    const uniquePurls = [...new Set(withPurl.map(e => e.purl))];

    // chunk into safe sizes for querybatch
    const CHUNK = 100; // safe chunk size
    const chunks = chunkArray(uniquePurls, CHUNK);

    // Map purl => result from OSV (vuln ids)
    const purlToVulnIds = new Map();

    for (const chunk of chunks) {
        const results = await queryOsvBatch(chunk);
        // results align with chunk order
        for (let i = 0; i < chunk.length; i++) {
            const purl = chunk[i];
            const r = results[i] || {};
            const vulns = (r.vulns || []).map(v => v.id).filter(Boolean);
            purlToVulnIds.set(purl, vulns);
        }
    }

    // Gather unique vuln ids
    const uniqueVulnIds = new Set();
    for (const ids of purlToVulnIds.values()) ids.forEach(id => uniqueVulnIds.add(id));
    const uniqIdsArr = [...uniqueVulnIds];

    // Check cache and fetch missing
    const cached = await getCachedVulnDetails(uniqIdsArr);
    const missing = uniqIdsArr.filter(id => !cached.has(id));

    // Rate-limited fetch details (concurrency)
    const limit = pLimit(8); // concurrency 8
    const fetchPromises = missing.map(id => limit(async () => {
        try {
            const data = await fetchVulnDetail(id);
            await cacheVulnDetail(id, data);
            return { id, data };
        } catch (err) {
            console.error('Failed to fetch vuln detail', id, err);
            return { id, data: null, error: String(err) };
        }
    }));
    const fetched = await Promise.all(fetchPromises);

    // Build final map
    const finalMap = new Map(cached); // start with cached
    for (const f of fetched) {
        if (f.data) finalMap.set(f.id, f.data);
    }

    // Build per-component results
    const componentsResult = extracted.map(e => {
        const purl = e.purl;
        const vulnIds = purl ? (purlToVulnIds.get(purl) || []) : [];
        const vulns = vulnIds.map(id => ({ id, detail: finalMap.get(id) || null }));
        return {
            purl,
            name: e.name,
            version: e.version,
            vulnIds,
            vulnCount: vulnIds.length,
            vulns
        };
    });

    const componentsWithVulns = componentsResult.filter(c => c.vulnCount > 0).length;
    const totalVulnCount = [...purlToVulnIds.values()].reduce((acc, arr) => acc + (arr || []).length, 0);

    return {
        summary: {
            totalComponents,
            componentsWithVulns,
            totalVulnCount,
            uniqueVulnIds: uniqIdsArr
        },
        components: componentsResult
    };
}

/**
 * Normalize severity from OSV detail.
 * Prefer database_specific.severity string if present (e.g. 'HIGH').
 * Otherwise inspect a severity array (OSV sometimes returns [{type, score, severity}, ...]).
 * Fallback: UNKNOWN.
 */
function deriveSeverityFromDetail(detail) {
    if (!detail) return 'UNKNOWN';

    // 1) database_specific.severity (your sample had database_specific.severity='HIGH')
    if (detail.database_specific && typeof detail.database_specific.severity === 'string') {
        return String(detail.database_specific.severity).toUpperCase();
    }

    // 2) OSV detail may include a severity array: [{type: 'CVSS_V3', score: '9.8', severity: 'HIGH'}, ...]
    if (Array.isArray(detail.severity) && detail.severity.length > 0) {
        for (const s of detail.severity) {
            if (!s) continue;
            // if object with 'severity' or 'score'
            if (s.severity && typeof s.severity === 'string') return s.severity.toUpperCase();
            if (s.score) {
                const n = Number(s.score);
                if (!Number.isNaN(n)) {
                    if (n >= 9.0) return 'CRITICAL';
                    if (n >= 7.0) return 'HIGH';
                    if (n >= 4.0) return 'MODERATE';
                    if (n > 0.0) return 'LOW';
                }
            }
        }
    }

    // 3) Try CVSS-like structures (detail.cvss ...)
    if (detail.cvss) {
        const cv = detail.cvss['3.1'] || detail.cvss['3.0'] || detail.cvss;
        const score = (cv && (cv.baseScore || cv.score));
        if (score !== undefined && score !== null) {
            const n = Number(score);
            if (!Number.isNaN(n)) {
                if (n >= 9.0) return 'CRITICAL';
                if (n >= 7.0) return 'HIGH';
                if (n >= 4.0) return 'MODERATE';
                if (n > 0.0) return 'LOW';
            }
        }
    }

    return 'UNKNOWN';
}

/**
 * Extract discussion / reference URLs in a safe way; OSV 'references' is an array of objects,
 * each may have 'url', 'type', 'name'. We return unique url strings.
 */
function extractReferences(detail) {
    if (!detail || !Array.isArray(detail.references)) return [];
    const urls = new Set();
    for (const r of detail.references) {
        if (!r) continue;
        if (typeof r === 'string') {
            urls.add(r);
            continue;
        }
        // r.url is common; otherwise try r.url, r.reference, r.url_raw, r.href
        const url = r.url || r.reference || r.href || r.url_raw || (r.references && r.references.url);
        if (url && typeof url === 'string') urls.add(url);
    }
    return Array.from(urls);
}

/**
 * Extract 'fixedIn' versions from an OSV detail. OSV affected[] entries commonly have 'ranges' with events
 * containing 'fixed' version strings, or an 'versions' array.
 */
function extractFixedIn(detail) {
    if (!detail || !Array.isArray(detail.affected)) return [];
    const versions = new Set();
    for (const aff of detail.affected) {
        if (Array.isArray(aff.versions)) {
            for (const v of aff.versions) {
                if (v) versions.add(String(v));
            }
        }
        if (Array.isArray(aff.ranges)) {
            for (const r of aff.ranges) {
                if (Array.isArray(r.events)) {
                    for (const ev of r.events) {
                        if (ev && ev.fixed) versions.add(String(ev.fixed));
                    }
                }
            }
        }
    }
    return Array.from(versions).filter(Boolean);
}

/**
 * Map scanner's components array into the Mongoose finding schema shape.
 * Accepts the componentsResult you currently produce (purl,name,version,vulnIds,vulns...)
 * and map into:
 *   {
 *     purl,
 *     componentName,
 *     componentVersion,
 *     vulnerabilities: [
 *       { id, summary, severity, score, references, published, fixedIn, source }
 *     ]
 *   }
 */
function mapComponentToFinding(componentObj) {
    const purl = componentObj.purl || null;
    const name = componentObj.name || (componentObj.component && (componentObj.component.name || componentObj.component.purl)) || null;
    const version = componentObj.version || (componentObj.component && componentObj.component.version) || null;

    let vulnItems = [];
    const rawVulns = Array.isArray(componentObj.vulns) ? componentObj.vulns : [];

    for (const v of rawVulns) {
        // v expected like: { id: 'GHSA-...', detail: { ...osv detail... } }
        const id = v && (v.id || (v.detail && v.detail.id)) || null;
        const detail = (v && (v.detail || v.data)) || null;

        // Summary: prefer detail.summary, fallback to first line of detail.details if long
        let summary = '';
        if (detail) {
            if (detail.summary && typeof detail.summary === 'string') summary = detail.summary.trim();
            else if (detail.details && typeof detail.details === 'string') {
                // take first non-empty paragraph or first 200 chars
                const s = detail.details.trim();
                const firstPara = s.split('\n\n')[0] || s;
                summary = firstPara.length > 400 ? firstPara.slice(0, 400) + '...' : firstPara;
            }
        }

        // Published date: prefer detail.published, detail.published_at, detail.modified
        let published = null;
        const pubCandidates = [detail && detail.published, detail && detail.published_at, detail && detail.modified];
        for (const c of pubCandidates) {
            if (c) {
                const d = new Date(c);
                if (!Number.isNaN(d.getTime())) {
                    published = d;
                    break;
                }
            }
        }

        // Severity: prefer database_specific.severity, then severity array, then cvss
        const severity = deriveSeverityFromDetail(detail);

        // Score: try to find numeric cvss score if present
        let score = null;
        try {
            if (detail) {
                // severity entries sometimes contain score
                if (Array.isArray(detail.severity)) {
                    for (const s of detail.severity) {
                        if (s && (s.score || s.value)) {
                            const n = Number(s.score || s.value);
                            if (!Number.isNaN(n)) { score = n; break; }
                        }
                    }
                }
                if (score == null && detail.cvss) {
                    const cv = detail.cvss['3.1'] || detail.cvss['3.0'] || detail.cvss;
                    if (cv && (cv.baseScore || cv.score)) {
                        const n = Number(cv.baseScore || cv.score);
                        if (!Number.isNaN(n)) score = n;
                    }
                }
            }
        } catch (e) { score = null; }

        // References: list of URL strings
        const references = extractReferences(detail);

        // Fixed in versions
        const fixedIn = extractFixedIn(detail);

        // Source: prefer database_specific.source if present
        const source = (detail && detail.database_specific && detail.database_specific.source) || 'OSV';


        vulnItems.push({
            id,
            summary,
            severity,
            score: score === null ? null : Number(score),
            references,
            published,
            fixedIn,
            source
        });
    }

    return {
        purl,
        componentName: name,
        componentVersion: version,
        vulnerabilities: vulnItems
    };
}

/**
 * Convert the raw scan result (your current return)
 * into the DB schema: { summary: {...}, findings: [...] }
 */

function formatVulnResult(rawScan) {
    if (!rawScan) return null;

    const summaryRaw = rawScan.summary || {};
    const scannerVersion = rawScan.scannerVersion || 'osv';
    const source = rawScan.source || 'OSV';

    // components: accept multiple possible keys
    const components = rawScan.components || rawScan.componentsResult || rawScan.componentsResult || [];

    // map to findings
    const findings = Array.isArray(components) ? components.map(mapComponentToFinding).filter(f => Array.isArray(f.vulnerabilities) && f.vulnerabilities.length !== 0) : [];

    // compute severity counts
    const bySeverity = { critical: 0, high: 0, moderate: 0, low: 0, unknown: 0 };
    let totalVulnCount = 0;
    for (const f of findings) {
        const vulnList = Array.isArray(f.vulnerabilities) ? f.vulnerabilities : [];
        totalVulnCount += vulnList.length;
        for (const v of vulnList) {
            const s = (v.severity || 'UNKNOWN').toLowerCase();
            if (s.includes('critical')) bySeverity.critical++;
            else if (s.includes('high')) bySeverity.high++;
            else if (s.includes('moderate') || s.includes('medium')) bySeverity.moderate++;
            else if (s.includes('low')) bySeverity.low++;
            else bySeverity.unknown++;
        }
    }

    const finalSummary = {
        total: summaryRaw.totalVulnCount || totalVulnCount || (summaryRaw.total || 0),
        bySeverity,
        scannedAt: new Date(),
        scannerVersion,
        source
    };

    return {
        summary: finalSummary,
        findings
    };
}

// Export (if module.exports object below exists)
module.exports = {
    scanSbom,
    formatVulnResult
};


module.exports = {
    scanSbom,
    formatVulnResult,
};
